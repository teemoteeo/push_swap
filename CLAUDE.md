# CLAUDE.md - AI Assistant Guide for push_swap

## Project Overview

**push_swap** is a 42 School project implementing a sorting algorithm using two stacks (A and B) with limited operations. The goal is to sort integers with the fewest possible operations.

- **Author**: Timoteo Costantini Scala (tcostant)
- **Algorithm**: Radix Sort (bit manipulation approach)
- **Performance**: ~500 ops for 100 numbers, ~4000 ops for 500 numbers
- **Complexity**: O(n·k) where k = bit depth

## Directory Structure

```
push_swap/
├── Makefile              # Build system (creates push_swap.a archive)
├── push_swap.h           # Main header with structs and function declarations
├── push_swap.c           # Main entry point, parsing, initialization
├── push_swap_utils1.c    # Utility functions (find_min, find_max, bit_depth)
├── radix_sort.c          # Core sorting algorithm
├── swap.c                # sa, sb, ss operations
├── push.c                # pa, pb operations
├── rotate.c              # ra, rb, rr operations
├── reverse_rotate.c      # rra, rrb, rrr operations
├── libft/
│   └── ft_convert.c      # ft_atoi, ft_itoa implementations
├── README.md             # Project documentation
└── CLAUDE.md             # This file
```

## Build Commands

```bash
make          # Build push_swap.a (static library archive)
make clean    # Remove object files (.o)
make fclean   # Remove object files and archive (.a)
make re       # Full rebuild (fclean + all)
```

**Compiler flags**: `-Wall -Wextra -Werror` (strict mode, no warnings allowed)

**Note**: The Makefile creates a static library (`push_swap.a`). To create an executable, you may need to link with a main function or modify the build process.

## Code Style Conventions (42 School Norm)

### File Headers
Every file must have the 42 header (auto-generated by 42 header plugin):
```c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   filename.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: login <email>                              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: YYYY/MM/DD HH:MM:SS by user          #+#    #+#             */
/*   Updated: YYYY/MM/DD HH:MM:SS by user         ###   ########.fr        */
/*                                                                            */
/* ************************************************************************** */
```

### Naming Conventions
- **Structs**: `s_` prefix (e.g., `struct s_node`, `struct s_stack`)
- **Typedefs**: `t_` prefix (e.g., `t_node`, `t_stack`)
- **Functions**: lowercase with underscores (e.g., `init_stack`, `parse_input`)
- **Stack operations**: 2-3 letter abbreviations (sa, sb, ss, pa, pb, ra, rb, rr, rra, rrb, rrr)

### Code Style
- Tabs for indentation (not spaces)
- K&R brace style
- Maximum 5 functions per file
- Maximum 25 lines per function
- No inline comments on code lines (comments above or separate)
- All variables declared at the start of functions
- No `for` loops (use `while` instead)

## Data Structures

### Node (`t_node`)
```c
typedef struct s_node
{
    int             value;   // The integer value
    int             index;   // Position/rank (used for normalization)
    struct s_node   *next;   // Pointer to next node
} t_node;
```

### Stack (`t_stack`)
```c
typedef struct s_stack
{
    t_node  *top;   // Pointer to top element
    int     size;   // Number of elements
} t_stack;
```

Stacks are implemented as singly linked lists with the `top` pointing to the first element.

## Stack Operations

| Operation | Action | Output |
|-----------|--------|--------|
| `sa` | Swap top 2 elements of stack A | prints "sa\n" |
| `sb` | Swap top 2 elements of stack B | prints "sb\n" |
| `ss` | sa and sb simultaneously | prints "ss\n" |
| `pa` | Push top of B onto A | prints "pa\n" |
| `pb` | Push top of A onto B | prints "pb\n" |
| `ra` | Rotate A (top goes to bottom) | prints "ra\n" |
| `rb` | Rotate B (top goes to bottom) | prints "rb\n" |
| `rr` | ra and rb simultaneously | prints "rr\n" |
| `rra` | Reverse rotate A (bottom goes to top) | prints "rra\n" |
| `rrb` | Reverse rotate B (bottom goes to top) | prints "rrb\n" |
| `rrr` | rra and rrb simultaneously | prints "rrr\n" |

## Algorithm: Radix Sort

The algorithm sorts by processing bits from Most Significant Bit (MSB) to Least Significant Bit (LSB):

1. **Normalize values**: Subtract minimum value to handle negatives
2. **Calculate bit depth**: Determine number of bits needed for max value
3. **For each bit position** (MSB to LSB):
   - Iterate through all elements in stack A
   - If bit is 0: push element to B (`pb`)
   - If bit is 1: rotate A (`ra`)
   - After processing all elements: push everything from B back to A
4. Result: Sorted stack A

**Key file**: `radix_sort.c:15-43`

## Key Functions

| Function | File | Purpose |
|----------|------|---------|
| `main()` | push_swap.c:86 | Entry point, orchestrates program flow |
| `init_stack()` | push_swap.c:18 | Allocate and initialize empty stack |
| `free_stack()` | push_swap.c:30 | Free all memory in stack |
| `parse_input()` | push_swap.c:45 | Parse argv into linked list |
| `is_sorted()` | push_swap.c:70 | Check if stack is already sorted |
| `radix_sort()` | radix_sort.c:15 | Main sorting algorithm |
| `find_min()` | push_swap_utils1.c | Find minimum value in stack |
| `find_max()` | push_swap_utils1.c | Find maximum value in stack |
| `bit_depth()` | push_swap_utils1.c | Calculate bits needed for max value |
| `ft_atoi()` | libft/ft_convert.c | String to integer conversion |

## Development Workflow

### Adding New Operations
1. Implement the base operation in the appropriate file (swap.c, push.c, etc.)
2. Add the wrapper function that prints the operation name
3. Declare the function in `push_swap.h`
4. Update the Makefile if adding new source files

### Testing
```bash
# Basic test
./push_swap 3 2 1 0

# Count operations
./push_swap 3 2 1 0 | wc -l

# With checker (if available)
ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker $ARG
```

### Memory Checking
```bash
valgrind --leak-check=full ./push_swap 3 2 1 0
```

## Known Issues

1. **Missing libft.h**: The file `libft/libft.h` is referenced in `push_swap.h:18` but not present in the repository. This will cause compilation to fail. The header should declare:
   ```c
   int   ft_atoi(const char *str);
   char  *ft_itoa(int n);
   ```

2. **Output is a library**: The Makefile creates `push_swap.a` (static library) instead of an executable. To run as a program, the build may need adjustment.

## Input/Output Behavior

**Input**: Space-separated integers via command-line arguments
```bash
./push_swap 3 2 1 0
```

**Output**: One operation per line to stdout
```
pb
pb
ra
pa
pa
```

**Exit codes**:
- 0: Success (sorted or already sorted)
- Early return if argc < 2 (no input)

## Files by Category

### Core Logic
- `push_swap.c` - Main, init, parse, sorted check
- `radix_sort.c` - Sorting algorithm

### Stack Operations
- `swap.c` - sa, sb, ss
- `push.c` - pa, pb
- `rotate.c` - ra, rb, rr
- `reverse_rotate.c` - rra, rrb, rrr

### Utilities
- `push_swap_utils1.c` - find_min, find_max, bit_depth
- `libft/ft_convert.c` - ft_atoi, ft_itoa

### Configuration
- `Makefile` - Build system
- `push_swap.h` - All declarations

## Modifying the Algorithm

The current implementation uses radix sort which is efficient but not optimal for small sets. Common improvements:

- **Small sets (2-5 elements)**: Use hardcoded optimal sequences
- **Medium sets**: Consider Turkish algorithm or chunk-based approach
- **Large sets**: Current radix sort is appropriate

When modifying `radix_sort.c`, ensure:
- Proper normalization for negative numbers
- Correct bit depth calculation
- All elements return to stack A at the end
